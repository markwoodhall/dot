#+TITLE:  Emacs Config
#+AUTHOR: Mark Woodhall
#+PROPERTY: header-args

* ABOUT THIS CONFIG

This is a config evolved from Derek Taylors (distrotube) literate config.

* Symlinks

Always follow symlinks and edit the actual file. This is also set in init.el as it helps to do it early.

#+begin_src emacs-lisp
(setq vc-follow-symlinks t)
#+end_src

* A FEW PROGRAMS TO LOAD FIRST

The order in which the various Emacs modules load is very important.  So the very first code block is going to contain essential modules that many other modules will depend on later in this config.

** Setup Package.el To Work With MELPA

#+begin_src emacs-lisp
(require 'package)
(add-to-list 'package-archives
       '("melpa" . "https://melpa.org/packages/"))
;;(package-refresh-contents)
(package-initialize)
#+end_src

** Use-Package

Install use-package and enable ':ensure t' globally.  The ':ensure' keyword causes the package(s) within use-package statements to be installed automatically if not already present on your system.  To avoid having to add ':ensure t' to every use-package statement in this config, I set 'use-package-always-ensure'.

#+begin_src emacs-lisp
(unless (package-installed-p 'use-package)
  (package-install 'use-package))
(setq use-package-always-ensure t)
#+end_src

** History

Save history and limit to a sensible size.

#+begin_src emacs-lisp
(setq history-length 50)
(savehist-mode 1)
#+end_src

** Evil Mode

Evil is an extensible 'vi' layer for Emacs. It emulates the main features of Vim, and provides facilities for writing custom extensions.  Evil Collection is also installed since it adds 'evil' bindings to parts of Emacs that the standard Evil package does not cover, such as: calenda, help-mode adn ibuffer.

#+begin_src emacs-lisp
(use-package evil
  :ensure t
  :init      ;; tweak evil's configuration before loading it
  (setq evil-want-integration t) ;; This is optional since it's already set to t by default.
  (setq evil-want-keybinding nil)
  (setq evil-vsplit-window-right t)
  (setq evil-split-window-below t)
  (setq evil-search-module 'evil-search)
  (evil-mode 1))

(use-package evil-collection
  :after evil
  :config
  (setq evil-collection-mode-list '(dashboard dired ibuffer))
  :custom (evil-collection-setup-minibuffer t)
  :init (evil-collection-init))

(use-package evil-tutor)

(use-package evil-goggles
  :config
  (evil-goggles-mode))

(use-package evil-surround
  :config
  (global-evil-surround-mode 1))

#+end_src

*** Undo tree

Vim inspired undo history with support for redo.

#+begin_src emacs-lisp
(use-package undo-tree
  :ensure t
  :after evil
  :diminish
  :config
  (evil-set-undo-system 'undo-tree)
  (setq undo-tree-history-directory-alist '(("." . "~/.emacs.d/undo")))
  (global-undo-tree-mode 1))
#+end_src

** Escape to quit

I've got used to escape to quit in various places so its nice to have it here too.

#+begin_src emacs-lisp
(global-set-key (kbd "<escape>") 'keyboard-quit)
#+end_src

** General Keybindings

General.el allows us to set keybindings.  General makes setting keybindings (especially with SPC) much easier.  All of the keybindings we set later in the config depend on general being loaded.

#+begin_src emacs-lisp
(use-package general
  :ensure t
  :config
  (general-evil-setup t))
#+end_src

* GRAPHICAL USER INTERFACE TWEAKS

Let's make GNU Emacs look a little better.

** Disable Menubar, Toolbars and Scrollbars

#+begin_src emacs-lisp
(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
(tooltip-mode nil)
(setq frame-resize-pixelwise t)
#+end_src

** Display Line Numbers

#+begin_src emacs-lisp
(setq display-line-numbers-type 'relative)

(add-hook 'prog-mode-hook (lambda() (display-line-numbers-mode 1)))
(add-hook 'text-mode-hook (lambda() (display-line-numbers-mode 1)))

#+end_src

** Kind icons

#+begin_src emacs-lisp
(use-package kind-icon
  :ensure t)
#+end_src

** Wraps

#+begin_src emacs-lisp
(global-visual-line-mode -1)
(set-default 'truncate-lines t)
(auto-fill-mode -1)
#+end_src

* THEME

We need a nice colorscheme.

#+begin_src emacs-lisp
(use-package doom-themes)
(setq doom-themes-enable-bold t    ; if nil, bold is universally disabled
      doom-themes-enable-italic t) ; if nil, italics is universally disabled
;;(load-theme 'doom-tokyo-night t)

(add-to-list 'custom-theme-load-path "~/.emacs.d/themes")
(load-theme 'catppuccin t)

(setq catppuccin-flavor 'mocha) ;; or 'latte, 'macchiato, or 'mocha
(catppuccin-reload)
#+end_src

* STARTUP PERFORMANCE

  This section is where it make emacs faster to load.

** Garbage collection

Makes startup faster by reducing the frequency of garbage collection

#+begin_src emacs-lisp
;; Using garbage magic hack.
 (use-package gcmh
   :config
   (gcmh-mode 1))
;; Setting garbage collection threshold
(setq gc-cons-threshold 402653184
      gc-cons-percentage 0.6)

;; Profile emacs startup
(add-hook 'emacs-startup-hook
          (lambda ()
            (message "*** Emacs loaded in %s with %d garbage collections."
                     (format "%.2f seconds"
                             (float-time
                              (time-subtract after-init-time before-init-time)))
                     gcs-done)))

;; Silence compiler warnings as they can be pretty disruptive (setq comp-async-report-warnings-errors nil)
#+end_src

** Native Compil

#+begin_src emacs-lisp
;; Silence compiler warnings as they can be pretty disruptive
(if (boundp 'comp-deferred-compilation)
    (setq comp-deferred-compilation nil)
    (setq native-comp-deferred-compilation nil))
;; In noninteractive sessions, prioritize non-byte-compiled source files to
;; prevent the use of stale byte-code. Otherwise, it saves us a little IO time
;; to skip the mtime checks on every *.elc file.
(setq load-prefer-newer noninteractive)
#+end_src

* ALL THE ICONS

This is an icon set that can be used with dashboard, dired, ibuffer and other Emacs programs.

Note. May need to run all-the-icons-install-fonts

#+begin_src emacs-lisp
(use-package all-the-icons)
#+end_src

* BUFFERS AND BOOKMARKS

By default Emacs distinguishes between automatic and manual window switching. If you effect a window switch yourself with C-x b, it’s manual — and exempt from any display action rules you create yourself.

You probably don’t want that.

#+begin_src emacs-lisp
(setq switch-to-buffer-obey-display-actions t)
#+end_src

#+begin_src emacs-lisp
 (nvmap :prefix "SPC" :keymaps 'override
    "b"     '(:which-key "buffers")
    "b x"   '((lambda () (interactive) (kill-this-buffer) (evil-window-delete)) :which-key "Kill buffer")
    "b l"   '(counsel-ibuffer :which-key "List buffers")
    "b n"   '(next-buffer :which-key "Next buffer")
    "b n"   '(rename-buffer :which-key "Rename buffer")
    "b p"   '(previous-buffer :which-key "Previous buffer"))
#+end_src

** Tabs vs spaces!

Indent with spaces and setup trailing whitespace removal with ws-butler.

#+begin_src emacs-lisp
(setq-default indent-tabs-mode nil)
(use-package ws-butler)
(add-hook 'prog-mode-hook #'ws-butler-mode)
#+end_src

* Terminal

#+begin_src emacs-lisp
(use-package exec-path-from-shell)
(when (memq window-system '(mac ns x))
  (exec-path-from-shell-initialize))

(defun mw/named-vterm (name)
  "Starts a vterm and renames the buffer"
  (interactive "sTerminal name:")
  (vterm)
  (rename-buffer (concat "vterm-" name)))

#+end_src

** Bindings

#+begin_src emacs-lisp
(nvmap :prefix "SPC" :keymaps 'override
    "t"     '(:which-key "terminal")
    "t f"   '(mw/named-vterm :which-key "New Terminal")
    "t t"   '((lambda () (interactive) (projectile-run-vterm)) :which-key "New Terminal")
    "t s"   '((lambda () (interactive) (projectile-run-shell)) :which-key "New Shell"))
#+end_src

* DASHBOARD

Emacs Dashboard is an extensible startup screen showing you recent files, bookmarks, agenda items and an Emacs banner.

** Configuring Dashboard

#+begin_src emacs-lisp
(use-package dashboard
  :init      ;; tweak dashboard config before loading it
  (setq dashboard-set-heading-icons t)
  (setq dashboard-set-file-icons t)
  (setq dashboard-projects-backend 'projectile)
  (setq dashboard-icon-type 'all-the-icons)
  (setq dashboard-banner-logo-title "Emacs Is More Than A Text Editor!")
  (setq dashboard-startup-banner "~/.emacs.d/emacs-dash.png")  ;; use custom image as banner
  (setq dashboard-center-content t) ;; set to 't' for centered content
  (setq dashboard-vertically-center-content t)
  (setq dashboard-items '((recents . 9)
                          (projects . 5)))
  :config
  (dashboard-setup-startup-hook))
#+end_src

** Dashboard in Emacsclient

This setting ensures that emacsclient always opens on *dashboard* rather than *scratch*.

#+begin_src emacs-lisp
(setq initial-buffer-choice (lambda () (get-buffer "*dashboard*")))
#+end_src

* DELETE SELECTION MODE

By default in Emacs, we don't have ability to select text, and then start typing and our new text replaces the selection.  Let's fix that!

#+begin_src emacs-lisp
(delete-selection-mode t)
#+end_src

* EVALUATE ELISP EXPRESSIONS

I choose to use the format 'SPC e' plus 'key' for these (I also use 'SPC e' for 'eww' keybindings).

#+begin_src emacs-lisp
(nvmap :keymaps '(emacs-lisp-mode-map org-mode-map) :prefix "SPC"
  "m"   '(:which-key "major")
  "m e" '(:which-key "evaluation")
  "m e b" '(eval-buffer :which-key "Eval buffer")
  "m e e" '(eval-defun-at-point :which-key "Eval root expressions")
  "m e E" '(eval-sexp-at-point :which-key "Eval expressions"))
#+end_src

* FILES

** File-related Keybindings

#+begin_src emacs-lisp
(nvmap :states '(normal visual) :keymaps 'override :prefix "SPC"
       "f"     '(:which-key "files")
       "f f"   '(counsel-find-file :which-key "Find file")
       "f g"   '(counsel-rg :which-key "Grep files")
       "f r"   '(counsel-recentf :which-key "Recent files")
       "f s"   '(save-buffer :which-key "Save file")
       "f u"   '(sudo-edit-find-file :which-key "Sudo find file")
       "f C"   '(copy-file :which-key "Copy file")
       "f D"   '(delete-file :which-key "Delete file")
       "f R"   '(rename-file :which-key "Rename file")
       "f S"   '(write-file :which-key "Save file as...")
       "f U"   '(sudo-edit :which-key "Sudo edit file"))
#+end_src

** Installing Some Useful File-related Modules

#+begin_src emacs-lisp
(use-package sudo-edit) ;; Utilities for opening files with sudo
#+end_src

* FONTS

Defining our fonts.

** Setting The Font Face

#+begin_src emacs-lisp
(set-face-attribute 'default nil
  :font "JetBrains Mono"
  :height 95
  :weight 'medium)
(set-face-attribute 'variable-pitch nil
  :font "JetBrains Mono"
  :height 95
  :weight 'medium)
(set-face-attribute 'fixed-pitch nil
  :font "JetBrains Mono"
  :height 95
  :weight 'medium)
;; Makes commented text and keywords italics.
;; This is working in emacsclient but not emacs.
;; Your font must have an italic face available.
(set-face-attribute 'font-lock-comment-face nil
  :slant 'italic)
(set-face-attribute 'font-lock-keyword-face nil
  :slant 'italic)

;; Uncomment the following line if line spacing needs adjusting.
;; (setq-default line-spacing 0.05)

;; Needed if using emacsclient. Otherwise, your fonts will be smaller than expected.
(add-to-list 'default-frame-alist '(font . "JetBrains Mono-10"))
;; changes certain keywords to symbols, such as lamda!
(setq global-prettify-symbols-mode t)
#+end_src

* GENERAL KEYBINDINGS

General.el allows us to set keybindings.  As a longtime Doom Emacs user, I have grown accustomed to using SPC as the prefix key.  It certainly is easier on the hands than constantly using CTRL for a prefix.

#+begin_src emacs-lisp
(nvmap :keymaps 'override :prefix "SPC"
       "SPC"   '(counsel-M-x :which-key "All commands (M-x)")
       "h"     '(:which-key "help")
       "h r"   '(:which-key "reload")
       "h r e" '((lambda () (interactive) (load-file "~/.emacs.d/init.el")) :which-key "Reload emacs config"))
#+end_src

* Mode line

#+begin_src emacs-lisp
;; (use-package doom-modeline)
;; (doom-modeline-mode 1)
#+end_src

* Counsel

#+begin_src emacs-lisp
(use-package counsel)
(use-package smex)

(use-package ivy
  :defer 0.1
  :diminish
  :bind
  (("C-s" . swiper)
   :map evil-insert-state-map
   ("C-k" . ivy-previous-line)
   ("C-j" . ivy-next-line)
   :map ivy-minibuffer-map
   ("TAB" . ivy-alt-done)
   ("C-l" . ivy-alt-done)
   ("C-j" . ivy-next-line)
   ("C-k" . ivy-previous-line)
   :map ivy-switch-buffer-map
   ("C-k" . ivy-previous-line)
   ("C-j" . ivy-next-line)
   ("C-l" . ivy-done)
   ("C-d" . ivy-switch-buffer-kill)
   :map ivy-reverse-i-search-map
   ("C-k" . ivy-previous-line)
   ("C-j" . ivy-next-line)
   ("C-d" . ivy-reverse-i-search-kill))
  :custom
  (setq ivy-count-format "(%d/%d) ")
  (setq ivy-use-virtual-buffers t)
  (setq enable-recursive-minibuffers t)
  (add-to-list 'ivy-sort-functions-alist
               '(counsel-recentf . file-newer-than-file-p))
  :config
  (ivy-mode))
(use-package ivy-rich
  :after ivy
  :custom
  (ivy-virtual-abbreviate 'full
			  ivy-rich-switch-buffer-align-virtual-buffer t
			  ivy-rich-path-style 'abbrev)
  :config
  (ivy-set-display-transformer 'ivy-switch-buffer
                               'ivy-rich-switch-buffer-transformer)
  (ivy-rich-mode 1)) ;; this gets us descriptions in M-x.

(use-package ivy-xref
  :ensure t
  :init
  ;; xref initialization is different in Emacs 27 - there are two different
  ;; variables which can be set rather than just one
  (when (>= emacs-major-version 27)
    (setq xref-show-definitions-function #'ivy-xref-show-defs))
  ;; Necessary in Emacs <27. In Emacs 27 it will affect all xref-based
  ;; commands other than xref-find-definitions (e.g. project-find-regexp)
  ;; as well
  (setq xref-show-xrefs-function #'ivy-xref-show-xrefs))

#+end_src

* LANGUAGE SUPPORT

Adding packages for programming langauges, so we can have nice things like syntax highlighting.

#+begin_src emacs-lisp
(use-package clojure-mode)
(use-package lua-mode)
(use-package markdown-mode)
(use-package kotlin-mode)
(use-package fennel-mode)
(use-package terraform-mode)
#+end_src

** Language tools and config

Settings and packages for specific langauges

*** All

#+begin_src emacs-lisp
(use-package highlight-indent-guides
  :ensure t
  :diminish t
  :config
  (setq highlight-indent-guides-method 'column)
  :init
  (add-hook 'prog-mode-hook 'highlight-indent-guides-mode))

(use-package rainbow-delimiters
  :ensure t
  :diminish t
  :init
  (add-hook 'prog-mode-hook 'rainbow-delimiters-mode))
#+end_src

**** Compiler settings

#+begin_src emacs-lisp
(use-package ansi-color
  :hook (compilation-filter . ansi-color-compilation-filter))

(setq compilation-scroll-output t)
#+end_src

*** Kotlin

**** Bindings 

#+begin_src emacs-lisp
(nvmap :keymaps 'kotlin-mode-map :prefix "SPC"
  "m" '(:which-key "kotlin")
  "m i" '(:which-key "idea")
  "m i i" '(mw/idea-inspect-changes :which-key "Inspect changed code")
  "m i I" '(mw/idea-inspect-all :which-key "Inspect all code")
  "m m" '(:which-key "mvn")
  "m m c" '(mw/mvn-compile :which-key "Compile")
  "m m C" '(mw/mvn-compile-all :which-key "Compile all, including tests")
  "m m t" '(mw/mvn-test :which-key "Run tests")
  "m m T" '(mw/mvn-integration-test :which-key "Run integration tests")
  "m m s" '(mw/mvn-spring-boot-run :which-key "Run spring boot"))
#+end_src

*** NPM

Add an option to run an npm target as compilation and setup a shortcut to a tailwind watch target.

#+begin_src emacs-lisp
(defun mw/npm-run-target (target options)
  "Run npm run TARGET with OPTIONS."
  (interactive)
  (compile
   (mw/build-command " npm run " target options t t)))

(defun mw/npm-run-watch-tailwind ()
  "Run the mvn targets clean and compile."
  (interactive)
  (mw/npm-run-target "tailwindw" ""))
#+end_src

*** MVN

Helper functions to run mvn compile and test.

#+begin_src emacs-lisp
(use-package feature-mode)

(defun mw/read-env-file (filename replace-double-quotes)
  "Return the contents of FILENAME."
  (if (file-exists-p filename)
      (let* ((data (with-temp-buffer
                     (insert-file-contents filename)
                     (buffer-string)))
             (no-comments (replace-regexp-in-string "#.*\n" "" data nil 'literal))
             (no-exp (replace-regexp-in-string (regexp-quote "EXPORT ") "" no-comments nil 'literal))
             (no-new-lines (replace-regexp-in-string (regexp-quote "\n") " " no-exp nil 'literal))
             (no-double-quotes (if replace-double-quotes
                                  (replace-regexp-in-string (regexp-quote "\"") "" no-new-lines nil 'literal)
                                  no-new-lines)))
        no-double-quotes)
    ""))

(defun mw/build-command (cmd target options change-dir read-env)
  (let ((env (if read-env (mw/read-env-file (concat (projectile-project-root) "/.env") nil) ""))
        (cd (if change-dir (concat "cd " (projectile-project-root) "\n")))
        (command (if cmd (concat cmd " ") ""))
        (opts (if options (concat " " options) "")))
    (concat cd
            env
            command target opts)))

(defun mw/mvn-exec-target (target options)
  "Run the mvn TARGET with OPTIONS."
  (interactive)
  (compile
   (mw/build-command " mvn -Dstyle.color=always" target options t t)))

(defun mw/mvn-compile ()
  "Run the mvn targets clean and compile."
  (interactive)
  (mw/mvn-exec-target "clean compile" ""))

(defun mw/mvn-compile-all ()
  "Run the mvn targets clean, compile, and test-compile."
  (interactive)
  (mw/mvn-exec-target "clean compile test-compile" ""))

(defun mw/mvn-test ()
  "Run the mvn targets clean and test."
  (interactive)
  (mw/mvn-exec-target "clean test" ""))

(defun mw/mvn-integration-test ()
  "Run the mvn targets clean and integration-test."
  (interactive)
  (mw/mvn-exec-target "clean integration-test" ""))

(defun mw/mvn-spring-boot-run ()
  "Run the mvn targets clean and spring-boot:run."
  (interactive)
  (mw/mvn-exec-target "clean spring-boot:run" ""))
#+end_src

*** IDEA inspections

Functions to enable a compiler that calls idea code inspections

#+begin_src emacs-lisp
(defun mw/idea-exec-target (target options)
  "Run the idea TARGET with OPTIONS."
  (interactive)
  (compile
   (mw/build-command "PATH=\"/usr/lib/jvm/java-20-openjdk/bin/:$PATH\" idea.sh" target options t t)))

(defun mw/idea-inspect (options)
  "Run the idea inspect target."
  (interactive)
  (let ((project (projectile-project-root)))
    (mw/idea-exec-target
     "inspect"
     (concat project " " project ".idea/inspectionProfiles/Project_Default.xml ./inspection.txt -v0 -d " project "src "
             options
             " && cat ./inspection.txt"))))

(defun mw/idea-inspect-all ()
  (interactive)
  (mw/idea-inspect "-format plain"))

(defun mw/idea-inspect-changes ()
  (interactive)
  (mw/idea-inspect "-format plain -changes"))
#+end_src

*** Cucumber

Helper functions to run cucumber via mvn.

#+begin_src emacs-lisp
(use-package feature-mode)
(defun mw/cucumber-options (feature line glue)
  (let ((line-t (if line (concat ":" line) ""))
        (glue-str (if glue
                      (concat " -Dcucumber.glue=\"" glue "\"")
                    "")))
    (concat
     "-Dcucumber.features=\""
     feature
     line-t"\""
     glue-str)))

(defun mw/mvn-test-cucumber-target (feature line glue)
  "Run the mvn targets clean and test with cucumber options FEATURE LINE GLUE.
This specifies cucumber options for testing just the feature in file."
  (interactive)
  (let* ((cucumber-options (mw/cucumber-options feature line glue))
         (target "clean test-compile test"))
    (mw/mvn-exec-target target cucumber-options)))

(defun mw/mvn-test-cucumber-this-feature (glue)
  "Run the mvn targets clean and test for this feature with GLUE.
This specifies cucumber options for testing just the feature in file."
  (interactive)
  (mw/mvn-test-cucumber-target
   (buffer-file-name)
   nil
   glue))

(defun mw/mvn-test-cucumber-this-scenario (glue)
  "Run the mvn targets clean and test for this scenario.
This specifies cucumber options for testing just the scenario under cursor."
  (interactive)
  (mw/mvn-test-cucumber-target
   (buffer-file-name)
   (number-to-string
    (line-number-at-pos))
   glue))

(defun crossref/cucumber-current-manifold-glue-path ()
  (let* ((dir (file-name-directory (buffer-file-name)))
         (dir-parts (split-string dir "/"))
         (dir-parts-length (length dir-parts))
         (feature (elt dir-parts (- dir-parts-length 2)))
         (glue (concat "org.crossref.manifold.common,org.crossref.manifold." feature)))
    glue))

(defun crossref/mvn-test-cucumber-this-scenario ()
  "Run the crossref mvn targets clean and test for this scenario.
This specifies cucumber options for testing just the scenario under cursor."
  (interactive)
  (let* ((glue (crossref/cucumber-current-manifold-glue-path)))
    (mw/mvn-test-cucumber-this-scenario glue)))

(defun crossref/mvn-test-cucumber-this-feature ()
  "Run the crossref mvn targets clean and test for this feature.
This specifies cucumber options for testing just the feature in file."
  (interactive)
  (let* ((glue (crossref/cucumber-current-manifold-glue-path)))
    (mw/mvn-test-cucumber-this-feature glue)))

(nvmap :keymaps 'feature-mode-map :prefix "SPC"
  "m" '(:which-key "Cucumber")
  "m r" '(:which-key "Run")
  "m r a" '(mw/mvn-integration-test :which-key "Run all")
  "m r s" '((lambda () (interactive)
                         (let ((proj (projectile-project-root)))
                         (if (string-match "/manifold" proj)
                             (crossref/mvn-test-cucumber-this-scenario)
                             (mw/mvn-test-cucumber-this-scenario)))) :which-key "Run scenario")
  "m r f" '((lambda () (interactive)
                         (let ((proj (projectile-project-root)))
                         (if (string-match "/manifold" proj)
                             (crossref/mvn-test-cucumber-this-feature)
                             (mw/mvn-test-cucumber-this-feature)))) :which-key "Run feature"))
#+end_src


*** Docker

#+begin_src emacs-lisp
(use-package yaml)
(use-package docker)
(use-package dockerfile-mode)

#+end_src

*** SQL

#+begin_src emacs-lisp
(nvmap :keymaps 'sql-mode-map :prefix "SPC"
       "m p" '(:which-key "Connections")
       "m p c" '(sql-postgres :which-key "Connect to postgres")
       "m e r" '(sql-send-region :which-key "Eval sql region")
       "m e e" '(sql-send-paragraph :which-key "Eval sql paragraph"))
#+end_src

**** MSSQL

#+begin_src emacs-lisp
(setq sql-ms-program "sqlcmd")
(setq sql-ms-options '())
#+end_src

**** Connections

#+begin_src emacs-lisp
(setq sql-connection-alist
      '((local (sql-product 'postgres)
               (sql-port 5432)
               (sql-server "localhost"))
        (local5433 (sql-product 'postgres)
                   (sql-port 5433)
                   (sql-server "localhost"))))

(defun ms-connect (connection)
  (setq sql-product 'ms)
  (sql-connect connection))

(defun psql-connect (connection)
  (setq sql-product 'postgres)
  (sql-connect connection))

(defun psql-local ()
  (interactive)
  (psql-connect 'local))

(defun psql-local5433 ()
  (interactive)
  (psql-connect 'local5433))

#+end_src

*** Lisp

#+begin_src emacs-lisp
(use-package smartparens
  :ensure t
  :diminish t
  :init
  (add-hook 'org-mode-hook #'smartparens-mode)
  (add-hook 'clojure-mode-hook #'smartparens-mode)
  (add-hook 'kotlin-mode-hook #'smartparens-mode)
  (add-hook 'fennel-mode-hook #'smartparens-mode)
  (add-hook 'cider-repl-mode-hook #'smartparens-mode)
  (add-hook 'emacs-lisp-mode-hook #'smartparens-mode))

(defmacro def-pairs (pairs)
  "Define functions for pairing. PAIRS is an alist of (NAME . STRING)
conses, where NAME is the function name that will be created and
STRING is a single-character string that marks the opening character.

  (def-pairs ((paren . \"(\")
              (bracket . \"[\"))

defines the functions WRAP-WITH-PAREN and WRAP-WITH-BRACKET,
respectively."
  `(progn
     ,@(cl-loop for (key . val) in pairs
             collect
             `(defun ,(read (concat
                             "wrap-with-"
                             (prin1-to-string key)
                             "s"))
                  (&optional arg)
                (interactive "p")
                (sp-wrap-with-pair ,val)))))

(def-pairs ((paren . "(")
            (bracket . "[")
            (brace . "{")
            (single-quote . "'")
            (double-quote . "\"")
            (back-quote . "`")))

(nvmap :keymaps 'smartparens-mode-map :prefix "SPC"
  "s"   '(:which-key "smartparens")
  "s s"   '(:which-key "slurp")
  "s s b" '(sp-backward-slurp-sexp :which-key "Backward slurp sexp")
  "s s f" '(sp-forward-slurp-sexp :which-key "Forward slurp sexp")

  "s b"   '(:which-key "barf")
  "s b b" '(sp-backward-barf-sexp :which-key "Backward barf sexp")
  "s b f" '(sp-forward-barf-sexp :which-key "Forward barf sexp")

  "s u"   '(:which-key "unwrap")
  "s u b" '(sp-backward-unwrap-sexp :which-key "Unwrap expression")
  "s u r" '(sp-raise-sexp :which-key "Raise expression")

  "s w"   '(:which-key "wrap")
  "s w ("  '(wrap-with-parens :which-key "Wrap with parens")
  "s w )"  '(wrap-with-parens :which-key "Wrap with parens")
  "s w ["  '(wrap-with-brackets :which-key "Wrap with brackets")
  "s w ]"  '(wrap-with-brackets :which-key "Wrap with brackets")
  "s w {"  '(wrap-with-braces :which-key "Wrap with braces")
  "s w }"  '(wrap-with-braces :which-key "Wrap with braces")
  "s w \""  '(wrap-with-double-quotes :which-key "Wrap with double quotes")
  "s w '"  '(wrap-with-single-quotes :which-key "Wrap with single quotes")
  "s w _"  '(wrap-with-underscores :which-key "Wrap with underscores")
  "s w `"  '(wrap-with-back-quotes :which-key "Wrap with backticks"))
#+end_src

*** Clojure

#+begin_src emacs-lisp
(use-package cider)

(defun mw/nrepl-reset ()
  (interactive)
  (cider-interactive-eval
   "(dev/reset)"))

(defun mw/nrepl-dev ()
  (interactive)
  (cider-interactive-eval
   "(user/dev)"))

(defun mw/nrepl-go ()
  (interactive)
  (cider-interactive-eval
   "(dev/go)"))

(defun mw/nrepl-init-db ()
  (interactive)
  (cider-interactive-eval
   "(use 'db) (db/init-schema)"))

(defun mw/nrepl-migrate-db ()
  (interactive)
  (cider-interactive-eval
   "(use 'db) (db/migrate-schema)"))

(nvmap :keymaps 'clojure-mode-map :prefix "SPC"
  "m"   '(:which-key "major")
  "m e" '(:which-key "evaluation")
  "m r" '(:which-key "reloaded")

  "m r g" '(mw/nrepl-go :which-key "Go")
  "m r d" '(mw/nrepl-dev :which-key "Dev")
  "m r r" '(mw/nrepl-reset :which-key "Reset")
  "m r m" '(mw/nrepl-migrate-db :which-key "Migrate DB")
  "m r i" '(mw/nrepl-init-db :which-key "Init DB")

  "m e b" '(cider-eval-buffer :which-key "Cider eval buffer")
  "m e e" '(cider-eval-defun-at-point :which-key "Cider eval root expressions")
  "m e E" '(cider-eval-last-sexp :which-key "Cider eval expressions")

  "m t" '(:which-key "test")
  "m t p" '(cider-test-run-project-tests :which-key "Cider run project tests")
  "m t n" '(cider-test-run-ns-tests :which-key "Cider run ns tests")

  "m s" '(:which-key "sesman")
  "m s I" '(cider-jack-in-cljs :which-key "Cider jack in cljs")
  "m s i" '(cider-jack-in :which-key "Cider jack in"))
#+end_src

*** Fennel

#+begin_src emacs-lisp
(nvmap :keymaps 'fennel-mode-map :prefix "SPC"
  "m"   '(:which-key "major")
  "m e" '(:which-key "evaluation")

  "m e b" '(fennel-reload :which-key "Cider eval buffer")
  "m e e" '(fennel-eval-toplevel-form :which-key "Cider eval root expressions")
  "m e E" '(fennel-eval-last-sexp :which-key "Cider eval expressions")

  "m s" '(:which-key "sesman")
  "m s i" '(fennel-repl :which-key "Fennel REPL"))
#+end_src

* LSP

#+begin_src emacs-lisp
  (use-package lsp-ui)
  (use-package lsp-mode
    :config
   (setq lsp-semantic-tokens-enable t))
  (use-package lsp-treemacs)
  (use-package lsp-ivy)

  (add-hook 'sql-mode-hook 'lsp)
  (setq lsp-sqls-workspace-config-path nil)
  (setq lsp-sqls-connections
      '(((driver . "postgresql") (dataSourceName . "host=127.0.0.1 port=5432 user=bags password=bags dbname=bags sslmode=disable"))
       ((driver . "postgresql") (dataSourceName . "host=127.0.0.1 port=5432 user=pelly password=pelly dbname=pelly sslmode=disable"))
       ((driver . "postgresql") (dataSourceName . "host=127.0.0.1 port=5432 user=abv password=abv dbname=abv sslmode=disable"))))

  (add-hook 'clojure-mode-hook 'lsp)
  (add-hook 'clojurescript-mode-hook 'lsp)
  (add-hook 'clojurec-mode-hook 'lsp)
  (add-hook 'kotlin-mode-hook 'lsp)
  (add-hook 'fennel-mode-hook 'lsp)
  (setq lsp-enable-indentation nil)
  (setq read-process-output-max (* 1024 1024))

  (add-to-list 'lsp-language-id-configuration '(fennel-mode . "fennel"))

  (lsp-register-client (make-lsp-client
                        :new-connection (lsp-stdio-connection "fennel-ls")
                        :activation-fn (lsp-activate-on "fennel")
                        :server-id 'fennel-ls))

#+end_src

** Bindings

#+begin_src emacs-lisp
(nvmap :prefix ""
  "K" '(lsp-ui-doc-glance :which-key "Lsp Documentation"))

(nvmap :prefix "SPC"
  "l"   '(:which-key "lsp")
  "l g" '(:which-key "goto")
  "l g d" '(lsp-find-definition :which-key "Find definition")
  "l d" '(:which-key "diag")
  "l d r" '(lsp-find-references :which-key "Find references")
  "l d a" '(lsp-execute-code-action :which-key "LSP code actions")
  "l d D" '(lsp-treemacs-errors-list :which-key "Diagnotics"))
#+end_src

* Syntax Checking

#+begin_src emacs-lisp
(use-package flycheck
  :init (global-flycheck-mode))

(use-package flycheck-kotlin
  :config (add-to-list 'flycheck-checkers 'kotlin-ktlint))
#+end_src

* Completion

#+begin_src emacs-lisp
(use-package company)
(global-company-mode)

(use-package yasnippet)
(yas-global-mode 1)
#+end_src

* MAGIT

A git client for Emacs.  Often cited as a killer feature for Emacs.

#+begin_src emacs-lisp
(use-package magit
:config
(setq magit-display-buffer-function #'display-buffer))
 #+end_src

** Bindings

#+begin_src emacs-lisp
(nvmap :prefix "SPC" :keymaps 'override
  "g"   '(:which-key "git")
  "g g" '(counsel-git-grep :which-key "Grep git files")
  "g f" '(magit-find-file :which-key "Git files")
  "g F" '(magit-pull :which-key "Magit pull -rebase")
  "g P" '(magit-push :which-key "Magit push")
  "g s" '(magit-status :which-key "Magit status"))
#+end_src

** Git Gutters

#+begin_src emacs-lisp
(use-package git-gutter)
(global-git-gutter-mode +1)

#+end_src

* ORG MODE

Org Mode is =THE= killer feature within Emacs.  But it does need some tweaking.

** Defining A Few Things

#+begin_src emacs-lisp
(add-hook 'org-mode-hook 'org-indent-mode)
(setq org-directory "~/Org/"
      org-agenda-files '("~/Org/agenda.org")
      org-default-notes-file (expand-file-name "notes.org" org-directory)
      org-ellipsis " ▼ "
      org-log-done 'time
      org-journal-dir "~/Org/journal/"
      org-journal-date-format "%B %d, %Y (%A) "
      org-journal-file-format "%Y-%m-%d.org"
      org-hide-emphasis-markers t)
(setq org-src-preserve-indentation t
      org-src-tab-acts-natively t
      org-edit-src-content-indentation 0)
#+end_src

** Enabling Org Bullets

Org-bullets gives us attractive bullets rather than asterisks.

#+begin_src emacs-lisp
(use-package org-bullets)
(add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))
#+end_src

** Org Link Abbreviations

This allows for the use of abbreviations that will get expanded out into a lengthy URL.

#+begin_src emacs-lisp
;; An example of how this works.
;; [[arch-wiki:Name_of_Page][Description]]
(setq org-link-abbrev-alist    ; This overwrites the default Doom org-link-abbrev-list
        '(("google" . "http://www.google.com/search?q=")
          ("arch-wiki" . "https://wiki.archlinux.org/index.php/")
          ("ddg" . "https://duckduckgo.com/?q=")
          ("wiki" . "https://en.wikipedia.org/wiki/")))
#+end_src

** Org Todo Keywords

This lets us create the various TODO tags that we can use in Org.

#+begin_src emacs-lisp
  (setq org-todo-keywords        ; This overwrites the default Doom org-todo-keywords
          '((sequence
             "TODO(t)"           ; A task that is ready to be tackled
             "BLOG(b)"           ; Blog writing assignments
             "GYM(g)"            ; Things to accomplish at the gym
             "PROJ(p)"           ; A project that contains other tasks
             "VIDEO(v)"          ; Video assignments
             "WAIT(w)"           ; Something is holding up this task
             "|"                 ; The pipe necessary to separate "active" states and "inactive" states
             "DONE(d)"           ; Task has been completed
             "CANCELLED(c)" )))  ; Task has been cancelled
#+end_src

** Source Code Block Tag Expansion

Org-tempo is a package that allows for '<s' followed by TAB to expand to a begin_src tag.  Other expansions available include:

| Typing the below + TAB | Expands to ...                          |
|------------------------+-----------------------------------------|
| <a                     | '#+BEGIN_EXPORT ascii' … '#+END_EXPORT  |
| <c                     | '#+BEGIN_CENTER' … '#+END_CENTER'       |
| <C                     | '#+BEGIN_COMMENT' … '#+END_COMMENT'     |
| <e                     | '#+BEGIN_EXAMPLE' … '#+END_EXAMPLE'     |
| <E                     | '#+BEGIN_EXPORT' … '#+END_EXPORT'       |
| <h                     | '#+BEGIN_EXPORT html' … '#+END_EXPORT'  |
| <l                     | '#+BEGIN_EXPORT latex' … '#+END_EXPORT' |
| <q                     | '#+BEGIN_QUOTE' … '#+END_QUOTE'         |
| <s                     | '#+BEGIN_SRC' … '#+END_SRC'             |
| <v                     | '#+BEGIN_VERSE' … '#+END_VERSE'         |

#+begin_src emacs-lisp
(use-package org-tempo
  :ensure nil) ;; tell use-package not to try to install org-tempo since it's already there.
#+end_src

** Source Code Block Syntax Highlighting

We want the same syntax highlighting in source blocks as in the native language files.

#+begin_src emacs-lisp
(setq org-src-fontify-natively t
    org-src-tab-acts-natively t
    org-confirm-babel-evaluate nil
    org-edit-src-content-indentation 0)
#+end_src

** Automatically Create Table of Contents

Toc-org helps you to have an up-to-date table of contents in org files without exporting (useful useful for README files on GitHub).  Use :TOC: to create the table.

#+begin_src emacs-lisp
  (use-package toc-org
    :commands toc-org-enable
    :init (add-hook 'org-mode-hook 'toc-org-enable))
#+end_src

** Make M-RET Not Add Blank Lines

#+begin_src emacs-lisp
(setq org-blank-before-new-entry (quote ((heading . nil)
                                         (plain-list-item . nil))))
#+end_src

** Org Export To Manpage Format

#+begin_src emacs-lisp
(use-package ox-man
  :ensure nil)
#+end_src

** Export to html/pdf/markdown

#+begin_src emacs-lisp
;; (defun org-mode-export-hook ()
;;    (add-hook 'after-save-hook 'org-html-export-to-html t t)
;;    (add-hook 'after-save-hook 'org-md-export-to-markdown t t))
;; (add-hook 'org-mode-hook #'org-mode-export-hook)
#+end_src

Syntax highlighting for org mode html exports.

Note. This changes theme while exporting to something that works better in light mode.

#+begin_src emacs-lisp
;; (defvar my-org-html-export-theme 'tsdh-light)
;; 
;; (defun my-with-theme (orig-fun &rest args)
;;   (load-theme my-org-html-export-theme)
;;   (unwind-protect
;;       (apply orig-fun args)
;;     (disable-theme my-org-html-export-theme)))
;; 
;; (with-eval-after-load "ox-html"
;;   (advice-add 'org-html-export-to-html :around 'my-with-theme))

(require 'htmlize)
(require 'ox-html)
#+end_src

** Code execution

#+begin_src emacs-lisp
(require 'ob-clojure)
(setq org-babel-clojure-backend 'babashka)
(with-eval-after-load 'org
(org-babel-do-load-languages
 'org-babel-load-languages
 '((sql . t)
   (clojure . t)
   (shell . t))))
#+end_src

* PROJECTILE

#+begin_src emacs-lisp
(use-package projectile
  :config
  (projectile-global-mode 1)
  :init
  (when (file-directory-p "~/src")
    (setq projectile-project-search-path '("~/src")))
  (setq projectile-switch-project-action #'projectile-dired))
#+end_src

** Bindings

#+begin_src emacs-lisp
(nvmap :keymaps 'override :prefix "SPC"
       "p"     '(:which-key "projects")
       "p f"   '(projectile-find-file :which-key "Find file"))
#+end_src

* SCROLLING

Emacs' default scrolling is annoying because of the sudden half-page jumps.  Also, I wanted to adjust the scrolling speed.

#+begin_src emacs-lisp
(setq scroll-conservatively 101) ;; value greater than 100 gets rid of half page jumping
(setq mouse-wheel-scroll-amount '(3 ((shift) . 3))) ;; how many lines at a time
(setq mouse-wheel-progressive-speed t) ;; accelerate scrolling
(setq mouse-wheel-follow-mouse 't) ;; scroll window under mouse
#+end_src

* SHELLS

** Vterm

Vterm is a terminal emulator within Emacs.  The 'shell-file-name' setting sets the shell to be used in M-x shell, M-x term, M-x ansi-term and M-x vterm.  By default, the shell is set to 'fish' but could change it to 'bash' or 'zsh' if you prefer.

#+begin_src emacs-lisp
(use-package vterm)

(setq-default explicit-shell-file-name "/bin/zsh")

(setq shell-file-name "/bin/zsh"
      vterm-shell "/bin/zsh"
      vterm-max-scrollback 9000)

(nvmap :keymaps '(override vterm-mode-map) :prefix "C-c"
  "C-c"   '(vterm--self-insert :which-key "Literal Ctrl C")
  "C-d"   '(vterm--self-insert :which-key "Literal Ctrl D"))

#+end_src

* SPLITS AND WINDOW CONTROLS

#+begin_src emacs-lisp
(winner-mode 1)

(add-to-list 'display-buffer-alist
          `((derived-mode . magit-mode)
            (display-buffer-in-side-window)
            (mode magit-mode)
            (window-height . 0.33)
            (side . bottom)
            (slot . 0)))

(add-to-list 'display-buffer-alist
     '("\*vterm\*"
       (display-buffer-in-side-window)
       (window-height . 0.33)
       (side . bottom)
       (slot . 0)))

(add-to-list 'display-buffer-alist
     '("\*compilation\*"
       (display-buffer-in-side-window)
       (window-height . 0.33)
       (side . bottom)
       (slot . 0)))

(add-to-list 'display-buffer-alist
     '("\*Compile-Log\*"
       (display-buffer-in-side-window)
       (window-height . 0.33)
       (side . bottom)
       (slot . 0)))

(add-to-list 'display-buffer-alist
     '("\*Flymake\*"
       (display-buffer-in-side-window)
       (window-height . 0.33)
       (side . bottom)
       (slot . 0)))

(add-to-list 'display-buffer-alist
     '("\*cider-repl\*"
       (display-buffer-in-side-window)
       (window-height . 0.33)
       (side . bottom)
       (slot . 0)))

(add-to-list 'display-buffer-alist
     '("\*Fennel REPLl\*"
       (display-buffer-in-side-window)
       (window-height . 0.33)
       (side . bottom)
       (slot . 0)))

(add-to-list 'display-buffer-alist
     '("\*sqls results\*"
       (display-buffer-in-side-window)
       (window-height . 0.33)
       (side . bottom)
       (slot . 0)))

(add-to-list 'display-buffer-alist
     '("\*SQL\*"
       (display-buffer-in-side-window)
       (window-height . 0.33)
       (side . bottom)
       (slot . 0)))

(nvmap :keymaps 'override :prefix "SPC"
       "w"     '(:which-key "windows")
       "w c"   '(evil-window-delete :which-key "Close window")
       "w n"   '(evil-window-new :which-key "New window")
       "w S"   '(evil-window-split :which-key "Horizontal split window")
       "w s"   '(evil-window-vsplit :which-key "Vertical split window")
       ;; Window motions
       "w h"   '(evil-window-left :which-key "Window left")
       "w j"   '(evil-window-down :which-key "Window down")
       "w k"   '(evil-window-up :which-key "Window up")
       "w l"   '(evil-window-right :which-key "Window right")
       "w w"   '(evil-window-next :which-key "Goto next window"))
#+end_src

* WHICH KEY

Which-key is a minor mode for Emacs that displays the key bindings following your currently entered incomplete command (a prefix) in a popup.

=NOTE:= Which-key has an annoying bug that in some fonts and font sizes, the bottom row in which key gets covered up by the modeline.

#+begin_src emacs-lisp
(use-package which-key
  :init
  (setq which-key-side-window-location 'bottom
        which-key-sort-order #'which-key-key-order-alpha
        which-key-sort-uppercase-first nil
        which-key-add-column-padding 1
        which-key-max-display-columns nil
        which-key-min-display-lines 6
        which-key-side-window-slot -10
        which-key-side-window-max-height 0.25
        which-key-idle-delay 0.8
        which-key-max-description-length 25
        which-key-allow-imprecise-window-fit t
        which-key-separator " → " ))
(which-key-mode)
(which-key-setup-minibuffer)
#+end_src

* RUNTIME PERFORMANCE

Dial the GC threshold back down so that garbage collection happens more frequently but in less time.

#+begin_src emacs-lisp
;; Make gc pauses faster by decreasing the threshold.
(setq gc-cons-threshold (* 2 1000 1000))
#+end_src
